이 노트는 프로젝트의 전반적인 설명을 담당합니다.

이 프로젝트는 C로 콘솔창에 tetris를 구현하는 목표를 가지고 있습니다.

by Maybe(maybe@hanyang.ac.kr)


Step 0. 들어가기에 앞서
	이 프로젝트의 전반적 개괄에 관한 사항은 Tumblr(http://maytryark.tumblr.com/) 와 facebook(https://www.facebook.com/MayTryArk)에 개재될 예정입니다.
	
	이 프로젝트를 진행하려면 먼저 기본적인 C의 입출력부터 변수와 상수, 함수, 구조체 등등에 대한 기초지식이 필요합니다.
		-물론 주석은 충분히 달 예정입니다.

Step 1. 계획 & 구상
	TETRIS란?(https://ko.wikipedia.org/wiki/%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4)
		-간단히 7개의 테트로미노(4개의 사각형으로 이루어진)를 이용하여 수평선을 빈틈 없이 채우는 게임.

	먼저 화면의 구성부터 시작.
	화면 구성은 크게 게임을 진행하는 부분과 여러 정보를 나타내는 부분으로 나눌 수 있다.(참조-\res\화면구성.png)

	1. 이러한 화면 구성을 위해 우리는 콘솔창의 크기를 조절해야합니다.
		-아래 구문을 사용하여 콘솔창의 크기를 x, y로 조절할 수 있습니다.
			system("mode con:cols=x linew=y");
		-x우리는 35, 20으로 설정합시다.
		-하다보니 35, 25가 더 나은것 같다.

Step 2. 화면 구성
	printf()를 적절히 이용해 다음과 같은 화면을 만들어봅시다.(참조-\res\화면구성_console.png)

	1. 이 화면구성을 매번 출력한다면 화면이 깜빡이는 현상이 나타나게됩니다.
	따라서 화면을 매번 새로고치지 않고 원하는 부분만 새로 고칠 수 있는 방법을 활용합니다.
		-Windows.h 의 SetConsoleCursorPosition과 GetStdHandle함수를 사용해서 원하는 위치에 콘솔커서를 옮길 수 있습니다.
		-아래 구문을 사용하여 x, y위치에 별을 출력해 봅시다.
			COORD cur = { x, y };
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cur);
			printf("☆");

		+위 코드는 두줄 정도 이지만 매번 위치를 옮기기 위해 이 두줄을 쓰는 과정은 너무 복잡합니다.
		+따라서 커서의 위치를 이동시켜주는 함수(cur2xy)를 하나 만들어 봅시다.
			void cur2xy(int x, int y)
			{
				COORD cur = { x, y };
				SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cur);
			}

	2. 배열에 의한 처리
	게임을 진행하는 부분을 하나의 커다란 2차원 배열로 볼 수 있을 것입니다.(참조-\res\array.png)
	우리가 구성한 실제 맵은 10x21의 크기이므로 좌우에 여백을 1개씩 두어도 12x23 크기의 배열을 선언하면 될 것입니다.
	이 배열에는 블럭인지 아닌지에 해당하는 데이터가 들어갈 것입니다.
	char형 [-127~128] 이면 충분한 데이터를 담을 수 있을 것 이므로 char형의 배열을 하나 선언해 줍시다.
		-변수를 선언합니다:	현재 맵 정보를 담는 배열(matrix)
			char matrix[12][23];

	!.그런데 우리가 맵 크기를 바꿀 수도 있지 않을까요?
		나중에 20x30으로 혹은 다른크기로 게임을 확장하려하는데 그 때마다 12,23을 매번 바꾸기 힘듭니다.
		전처리문으로 이러한 값의 변화에 유동적으로 대응할 수 있습니다.
		#define 구문을 사용하면 어떤 값을 문자로 대응시켜둘 수 있습니다,
		아래의 구문을 선언하고 다시 변수를 선언해봅시다.
			#define X 12
			#define Y 23
			char matrix[X][Y];
		앞으로 X, Y대신 12, 23이 들어간 것과 같습니다.
		//+여기에 변수 이름짓기 링크

Step 3. 테스트
	이 배열에 블럭을 만들어 배열 데이터가 변경되면 해당부분을 출력하는 함수와 변수들을 만들어 봅시다.

	아래와 같이 변수와 함수를 구성합니다.
		-변수를 선언합니다:	현재 맵 정보를 담는 배열(matrix), 출력된 맵 정보를 담는 배열(matrix_printed)
			char matrix[X][Y];
			char matrix_printed[X][Y];
		
		-함수를 만듭니다:		matrix, matrix_printed를 초기화 해주는 함수(initialize)
			void initialize()
			{
				int i, j;
				for (i = 0; i < Y; i ++)
				{
					for (j = 0; j < X; j++)
					{
						matrix_printed[i][j] = matrix[i][j] = 0;
						
					}
				}
			}

		-함수를 만듭니다:		matrix를 이용해 출력을 하고 matrix_printed를 matrix와 동기화 시키는 함수(print_matrix)
			void print_matrix()
			{
				int i, j;
				for (i = 0; i < Y; i++)
				{
					for (j = 0; j < X; j++)
					{
						if (matrix_printed[i][j] - matrix[i][j])
						{
							cur2xy(j*2,i);
							//2를곱해주는 이유는 기본 블럭의 가로 크기가 2이기 때문입니다.
							printf("■");
							matrix_printed[i][j] = matrix[i][j];
						}
					}
				}
			}

		main함수에 아래의 줄을 추가해 제대로 사각형이 출력되는지 봅시다.
			matrix[1][1] = 1;
			matrix[1][2] = 1;
			matrix[1][3] = 1;
			matrix[2][3] = 1;

		결과를 확인해봅시다.(참조-\res\result_3.png)
		!계속하려면 ~ 메세지가 중간에 나오는 것이 보기 싫으므로 마지막줄에 아래의 코드를 추가합니다.
			cur2xy(0,23);

Step4. 블럭 생성
	위와 같은 방식으로 모든 블럭을 생성할 순 없으니 블럭을 생성하는 함수를 만들어봅시다.
	
	그런데 블럭은 무조건 상단 중앙에서 생성되는 것을 상기해볼 필요가 있습니다.

	따라서 블럭 생성함수는 그 위치에 해당블럭을 생성하기만 하면 되는것이죠.

	블럭 전체의 정보를 넘겨주는것 보다 블럭의 종류가 한정적이므로 해당 블럭에 번호를 붙여 이 번호를 넘겨주는 것으로 하겠습니다.
	각 블럭은 다음과 같은 번호를 부여받습니다.(참조-\res\block.png)

	!앞으로 이 블럭들에 색을 입힐것이기 때문에 색에 대한 정보를 배열에 넣어주려고합니다.
	하지만 색을 일일히 기억하기 힘드므로 #define을 사용하여 값을 임으로 정의하고 나중에 추가하도록 하겠습니다.
	
	-정의합니다:				임시 색상
		enum COLOR { NONE, SKYBLUE, BLUE, ORANGE, YELLOW, RED, PUPLE, GREEN };
		//이 색상은 TTC 세계표준 테트리스 색상을 참조했습니다.
		//추후에 이 값을 토대로 색상을 적용시킬 것입니다.

		char BC[] = { NONE, SKYBLUE, BLUE, ORANGE, YELLOW, RED, PUPLE, GREEN };
		//각 블럭의 색상을 미리 정의해둡니다.


	!함수를 만들기전에
		블럭을 배열에 넣어주기 전에 우리는 몇 가지 생각을 더 해볼 수 있습니다.

			matrix[1][1] = 1;
			matrix[1][2] = 1;
			matrix[1][3] = 1;
			matrix[1][4] = 1;

		이렇게 쓰면 분명 1번 블럭이 생성될 것입니다.
		하지만 모든 블럭에 대한 경우를 각각 지정해주어야 합니다.
		그렇다면 아래의 코드는 어떨까요?

			int block_matrix_x[] = { 1, 2, 3, 4 }
			, block_matrix_y[] = { 1, 1, 1, 1 }
			, i, j;
			for (i = 0; i < 4; i++)
				matrix[block_matrix_y[i]][block_matrix_x[i]] = 1;

		위의 코드는 block_matrix 배열에 값을 담음으로써 반복적인 작업을 좀 더 효율적으로 처리했습니다.
		이 두가지의 차이가 이해되셨다면 아래의 함수를 만드는 일도 어렵지 않을겁니다.

	-함수를 만듭니다:		지정된 값을 받아 블럭을 만드는 함수(create_block)
		void create_block(char value)
		{
			int block_matrix_x[][4] = { { 1, 2, 3, 4 }, { 1, 1, 2, 3 }, { 1, 2, 3, 3 }, { 1, 1, 2, 2 }, { 1, 2, 2, 3 }, { 1, 2, 2, 3 }, { 1, 2, 2, 3 } }
				, block_matrix_y[][4] = { { 2, 2, 2, 2 }, { 1, 2, 2, 2 }, { 2, 2, 2, 1 }, { 1, 2, 1, 2 }, { 1, 1, 2, 2 }, { 2, 1, 2, 2 }, { 2, 2, 1, 1 } }
				, i, j;
			for (i = 0; i < 4; i++)
				matrix[block_matrix_y[value][i]][block_matrix_x[value][i]+3] = 1;
		}

	main함수 하단에 아래의 코드를 추가해서 블럭이 정상적으로 생성되나 확인해 봅시다.
		create_block(2);
		print_matrix();